# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# See `conversions.py.jinja` template in the `proto2ros.output.templates` Python module.
import array
import rclpy.serialization

{% for module_name in config.python_imports -%}
import {{ module_name }}
{% endfor %}
from proto2ros.conversions import convert
{% for module_name in config.inline_python_imports -%}
from {{ module_name }} import *
{% endfor -%}

{#
  Expands to code for ROS to Protobuf field conversion.

  Args:
    source: identifier of the ROS message field to convert from.
    destination: identifier of the Protobuf message field to convert to.
    spec: annotated ROS message field specification.
#}
{%- macro ros_to_proto_field_code(source, destination, spec) -%}
    {%- if not spec.type.is_primitive_type() -%}
        {%- set type_spec = config.known_message_specifications.get(to_ros_base_type(spec.type)) -%}
        {%- if type_spec and type_spec.annotations.get("proto-class") == "enum" -%}
            {#- Handle enum case i.e. extract integral values from ROS wrapper messages. -#}
            {%- if spec.type.is_array -%}
{{ destination }}.extend(item.value for item in {{ source }})
            {%- else -%}
{{ destination }} = {{ source }}.value
            {%- endif -%}
        {%- elif spec.type.is_array -%}
            {%- set input_item = itemize_python_identifier(source, "input_") -%}
            {%- set output_item = itemize_python_identifier(destination, "output_") -%}
            {%- if type_spec and type_spec.annotations.get("map-entry") -%}
                {#- Handle map case i.e. convert map entries, then update Protobuf messsage map. -#}
{{ output_item }} = {{ type_spec.annotations["proto-type"] | as_pb2_python_type }}()
for {{ input_item }} in {{ source }}:
    {{ ros_to_proto_composite_field_code_block(input_item, output_item, spec) | indent(4) }}
                {%- if type_spec.annotations.get("map-inplace") -%}
                {#- Then map value cannot be assigned, must be copied. #}
    {{ destination }}[{{ output_item }}.key].CopyFrom({{ output_item }}.value)
                {%- else %}
    {{ destination }}[{{ output_item }}.key] = {{ output_item }}.value
                {%- endif %}
            {%- else -%}{#- Handle sequence case i.e. just convert sequence items. #}
for {{ input_item }} in {{ source }}:
    {{ output_item }} = {{ destination }}.add()
    {{ ros_to_proto_composite_field_code_block(input_item, output_item, spec) | indent(4) }}
            {%- endif -%}
        {%- else -%}{#- Handle message case. -#}
{{ ros_to_proto_composite_field_code_block(source, destination, spec) }}
        {%- endif -%}
    {%- elif spec.annotations["proto-type"] == "bytes" -%}
        {#- Handle bytes case. -#}
        {%- if to_ros_base_type(spec.type) == "proto2ros/Bytes" -%}
{{ destination }}.extend(blob.data.tobytes() for blob in {{ source }})
        {%- else -%}
{{ destination }} = {{ source }}.tobytes()
        {%- endif -%}
    {%- else -%}{#- Handle primitive types case. -#}
        {%- if spec.type.is_array -%}
{{ destination }}.extend({{ source }})
        {%- else -%}
{{ destination }} = {{ source }}
        {%- endif -%}
    {%- endif -%}
{%- endmacro -%}

{#
  Expands to a code block for ROS to Protobuf composite field conversion.

  Args:
    source: identifier for the ROS message field to convert from.
    destination: identifier for the Protobuf message field to convert to.
    spec: annotated ROS message field specification.

  Note: code block may expand within a for-loop, during a repeated field expansion.
#}
{%- macro ros_to_proto_composite_field_code_block(source, destination, spec) -%}
    {%- set type_spec = config.known_message_specifications.get(to_ros_base_type(spec.type)) -%}
    {%- if spec.annotations.get("type-erased") -%}
        {#- ROS message must be deserialized for conversion. -#}
if {{ source }}.type != "{{ spec.type | as_ros_base_type }}":
    raise ValueError("expected {{ spec.type | as_ros_base_type }} message for {{ spec.name }} member, got %s" % {{ source }}.type)
typed_field_message = rclpy.serialization.deserialize_message({{ source }}.value.tobytes(), {{ spec.type | as_ros_base_type | as_ros_python_type }})
convert_{{ spec.type | as_ros_base_type | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto(typed_field_message, {{ destination }})
    {%- elif spec.annotations.get("type-casted") -%}
        {#- ROS message must be converted and packed for assignment. -#}
typed_proto_message = {{ proto_type_name | as_pb2_python_type }}()
convert_{{ spec.type | as_ros_base_type | as_python_idenfier }}_message_to_{{ proto_type_name | as_python_identifier }}_proto({{ source }}, typed_proto_message)
{{ destination }}.Pack(typed_proto_message)
    {%- elif spec.annotations.get("type-casts") -%}
        {#- ROS message must be deserialized according to type, then converted, then packed for assignment. -#}
match {{ source }}.type:
    {% for proto_type_name, ros_type_name in spec.annotations["type-casts"] -%}
    case "{{ ros_type_name }}":
        typed_field_message = rclpy.serialization.deserialize_message(
            {{ source }}.value.tobytes(), {{ ros_type_name | as_ros_python_type }})
        typed_proto_message = {{ proto_type_name | as_pb2_python_type }}()
        convert_{{ ros_type_name | as_python_identifier }}_message_to_{{ proto_type_name | as_python_identifier }}_proto(typed_field_message, typed_proto_message)
        {{ destination }}.Pack(typed_proto_message)
    {% endfor -%}
    case _:
        raise ValueError("unexpected %s in {{ spec.name }} member:" % ros_msg.{{ spec.name }}.type)
    {%- elif type_spec and type_spec.annotations.get("tagged") -%}
        {#- Handle one-of field case i.e. determine and convert the ROS message member that is set. -#}
        {%- set tag_field_spec = type_spec.annotations["tag"] -%}
match {{ source }}.{{ tag_field_spec.name }} or {{ source }}.{{ tag_field_spec.annotations["alias"] }}:
        {%- for tag_spec, member_spec in type_spec.annotations["tagged"] %}
    case {{ type_spec.base_type | string | as_ros_python_type }}.{{ tag_spec.name }}:
            {%- set source_member = source + "." + member_spec.name -%}
            {%- set destination_member = destination.rpartition(".")[0] + "." + member_spec.annotations.get("proto-name", member_spec.name) %}
        {{ ros_to_proto_field_code(source_member, destination_member, member_spec) | indent(8) }}
        {%- endfor %}
    case _:
        pass
    {%- else -%}
        {#- Handle the generic ROS message case (because it is appropriate or because we do not know any better). -#}
convert_{{ spec.type | as_ros_base_type | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto({{ source }}, {{ destination }})
    {%- endif -%}
{%- endmacro -%}

{#
  Expands to code for Protobuf to ROS field conversion.

  Args:
    source: identifier of the Protobuf message field to convert from.
    destination: identifier of the ROS message field to convert to.
    spec: annotated ROS message field specification.
#}
{%- macro proto_to_ros_field_code(source, destination, spec) -%}
    {%- if not spec.type.is_primitive_type() -%}
        {%- set type_spec = config.known_message_specifications.get(to_ros_base_type(spec.type)) -%}
        {%- if type_spec and type_spec.annotations.get("proto-class") == "enum" -%}
            {#- Handle enum case i.e. wrap integral values in ROS messages. -#}
            {%- if spec.type.is_array -%}
{{ destination }} = [{{ spec.type | as_ros_base_type | as_ros_python_type }}(value=value) for value in {{ source }}]
            {%- else -%}
{{ destination }}.value = {{ source }}
            {%- endif -%}
        {%- elif spec.type.is_array -%}
            {%- set input_item = itemize_python_identifier(source, "input_") -%}
            {%- set output_item = itemize_python_identifier(destination, "output_") -%}
            {%- if type_spec and type_spec.annotations.get("map-entry") %}
                {#- Handle map case i.e. reconstruct map entries, the convert, then assign. -#}
                {%- set input_iterable = input_item + "_entries" -%}
{{ input_iterable }} = [{{ type_spec.annotations["proto-type"] | as_pb2_python_type }}(key=key, value=value) for key, value in {{ source }}.items()]
            {%- else -%}
                {#- Handle sequence case. -#}
                {%- set input_iterable = source -%}
            {%- endif %}
for {{ input_item }} in {{ input_iterable }}:
            {%- if not spec.annotations.get("type-erased") %}
    {{ output_item }} = {{ spec.type | as_ros_base_type | as_ros_python_type }}()
            {%- else %}{#- It must convert to a type erased ROS message. #}
    {{ output_item }} = proto2ros.msg.Any()
            {%- endif %}
    {{ proto_to_ros_composite_field_code_block(input_item, output_item, spec) | indent(4) }}
    {{ destination }}.append({{ output_item }})
        {%- else -%}{#- Handle message case. -#}
{{ proto_to_ros_composite_field_code_block(source, destination, spec) }}
        {%- endif -%}
    {%- elif spec.annotations["proto-type"] == "bytes" -%}
        {#- Handle bytes case. -#}
        {%- if to_ros_base_type(spec.type) == "proto2ros/Bytes" -%}
{{ destination }} = [proto2ros.msg.Bytes(data=array.array("B", blob)) for blob in {{ source }}]
        {%- else -%}
{{ destination }} = array.array("B", {{ source }})
        {%- endif -%}
    {%- else -%}{#- Handle primitive types case. -#}
{{ destination }} = {{ source }}
    {%- endif -%}
{%- endmacro -%}

{#
  Expands to a code block for Protobuf to ROS composite field conversion.

  Args:
    source: identifier of the Protobuf message field to convert from.
    destination: identifier of the ROS message field to convert to.
    spec: annotated ROS message field specification.

  Note: code block may expand within a for-loop, during a repeated field expansion.
#}
{%- macro proto_to_ros_composite_field_code_block(source, destination, spec) -%}
    {%- set type_spec = config.known_message_specifications.get(to_ros_base_type(spec.type)) -%}
    {%- if spec.annotations.get("type-erased") -%}
        {#- ROS message must be serialized for assignment. -#}
typed_field_message = {{ spec.type | as_ros_base_type | as_ros_python_type }}()
convert_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto_to_{{ spec.type | as_ros_base_type | as_python_identifier }}_message({{ source }}, typed_field_message)
{{ destination }}.value = array.array("B", rclpy.serialization.serialize_message(typed_field_message))
{{ destination }}.type = "{{ spec.type | as_ros_base_type }}"
    {%- elif spec.annotations.get("type-casted") -%}
        {#- Protobuf message must be unpacked for conversion. -#}
typed_proto_message = {{ field_spec.annotations["proto-type"] | as_pb2_python_type }}()
{{ source }}.Unpack(typed_proto_message)
convert_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto_to_{{ spec.type | as_ros_base_type | as_python_identifier }}_message(typed_proto_message, {{ destination }})
    {%- elif spec.annotations.get("type-casts") -%}
        {#- Protobuf message must be unpacked according to type, then converted, then serialized for assignment. -#}
        {%- for proto_type_name, ros_type_name in spec.annotations["type-casts"] -%}
            {%- if loop.first -%}
if {{ source }}.Is({{ proto_type_name | as_pb2_python_type }}):
            {%- else -%}
elif {{ source }}.Is({{ proto_type_name | as_pb2_python_type }}):
            {%- endif -%}
    typed_proto_message = {{ proto_type_name | as_pb2_python_type }}()
    ok = {{ source }}.Unpack(typed_proto_message)
    assert ok, "Failed to unpack any protobuf, internal error"
    typed_field_message = {{ ros_type_name | as_ros_python_type }}()
    convert_{{ proto_type_name | as_python_identifier }}_proto_to_{{ ros_type_name | as_python_identifier }}_message(typed_proto_message, typed_field_message)
    {{ destination }}.value = array.array("B", rclpy.serialization.serialize_message(typed_field_message))
    {{ destination }}.type = "{{ ros_type_name }}"
        {%- endfor -%}
else:
    raise ValueError("unknown protobuf message type in {{ spec.name }} member: %s" %s {{ source }}.type_url)
    {%- elif type_spec and type_spec.annotations.get("tagged") -%}
        {#- Handle one-of field case i.e. determine and convert the Protobuf message member that is set. -#}
match {{ source.rpartition(".")[0] }}.WhichOneof("{{ spec.name }}"):
        {%- set tag_field_spec = type_spec.annotations["tag"] -%}
        {%- for tag_spec, member_spec in type_spec.annotations["tagged"] %}
    case "{{ member_spec.name }}":
        {%- set source_member = source.rpartition(".")[0] + "." + member_spec.annotations.get("proto-name", member_spec.name) -%}
        {%- set destination_member = destination + "." + member_spec.name %}
        {{ proto_to_ros_field_code(source_member, destination_member, member_spec) | indent(8) }}
        {{ destination }}.{{ tag_field_spec.name }} = {{ type_spec.base_type | string | as_ros_python_type }}.{{ tag_spec.name }}
        {{ destination }}.{{ tag_field_spec.annotations["alias"] }} = {{ destination }}.{{ tag_field_spec.name }}
        {%- endfor %}
    case _:
        {{ destination }}.{{ tag_field_spec.name }} = 0
        {{ destination }}.{{ tag_field_spec.annotations["alias"] }} = 0
    {%- else -%}
        {#- Handle the generic Protobuf message case (because it is appropriate or because we do not know any better). -#}
convert_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto_to_{{ spec.type | as_ros_base_type | as_python_identifier }}_message({{ source }}, {{ destination }})
    {%- endif -%}
{%- endmacro %}
{% for spec in message_specifications if spec.annotations.get("proto-class") == "message" %}
@convert.register({{ spec.base_type | string | as_ros_python_type }}, {{ spec.annotations["proto-type"] | as_pb2_python_type }})
def convert_{{ spec.base_type | string | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto(
    ros_msg: {{ spec.base_type | string | as_ros_python_type }}, proto_msg: {{ spec.annotations["proto-type"] | as_pb2_python_type }}
) -> None:
    """Converts from {{ spec.base_type }} ROS messages to {{ spec.annotations["proto-type"] }} Protobuf messages."""
    {%- if spec.fields %}
    proto_msg.Clear()
        {%- for field_spec in spec.fields if field_spec.name != "has_field" %}
            {%- set source = "ros_msg." + field_spec.name -%}
            {%- set destination = "proto_msg." + field_spec.annotations.get("proto-name", field_spec.name) -%}
            {%- if field_spec.annotations["optional"] %}{#- Check for field presence before use. #}
    if ros_msg.has_field & {{ spec.base_type | string | as_ros_python_type }}.{{ field_spec.name | upper }}_FIELD_SET:
        {{ ros_to_proto_field_code(source, destination, field_spec) | indent(8) }}
            {%- else %}
    {{ ros_to_proto_field_code(source, destination, field_spec) | indent(4) }}
            {%- endif -%}
        {% endfor %}
    {% else -%}{#- Handle empty message. #}
    pass
    {% endif %}

convert_{{ spec.base_type | string | as_python_identifier }}_to_proto = \
    convert_{{ spec.base_type | string | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto


@convert.register({{ spec.annotations["proto-type"] | as_pb2_python_type }}, {{ spec.base_type | string | as_ros_python_type }})
def convert_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto_to_{{ spec.base_type | string | as_python_identifier }}_message(
    proto_msg: {{ spec.annotations["proto-type"] | as_pb2_python_type }}, ros_msg: {{ spec.base_type | string | as_ros_python_type }}
) -> None:
    """Converts from {{ spec.annotations["proto-type"] }} Protobuf messages to {{ spec.base_type }} ROS messages."""
    {%- if spec.fields %}
        {%- if spec.annotations["has-optionals"] %}
    ros_msg.has_field = 0
        {%- endif -%}
        {%- for field_spec in spec.fields if field_spec.name != "has_field" -%}
           {%- set source = "proto_msg." + field_spec.annotations.get("proto-name", field_spec.name) -%}
           {%- set destination = "ros_msg." + field_spec.name -%}
           {%- if field_spec.annotations["optional"] -%}{#- Check for field presence before use. #}
    if proto_msg.HasField("{{ field_spec.annotations.get("proto-name", field_spec.name) }}"):
        {{ proto_to_ros_field_code(source, destination, field_spec) | indent(8) }}
        ros_msg.has_field |= {{ spec.base_type | string | as_ros_python_type }}.{{ field_spec.name | upper }}_FIELD_SET
            {%- else %}
    {{ proto_to_ros_field_code(source, destination, field_spec) | indent(4) }}
            {%- endif -%}
        {% endfor %}
    {% else -%}{#- Handle empty message. #}
    pass
    {% endif %}

convert_proto_to_{{ spec.base_type | string | as_python_identifier }} = \
    convert_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto_to_{{ spec.base_type | string | as_python_identifier }}_message

{% endfor -%}
