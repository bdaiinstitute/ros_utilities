# Copyright (c) 2023 Boston Dynamics AI Institute Inc.  All rights reserved.

from collections.abc import Sequence
from typing import Any, Iterator, Optional, TypeVar, Union

from rclpy.node import Node
from rclpy.qos import QoSProfile
from rclpy.task import Future

import message_filters
import rclpy.callback_groups
import rclpy.impl
import rclpy.node
import rclpy.qos
import rclpy.task

import bdai_ros2_wrappers.scope as scope
from bdai_ros2_wrappers.futures import wait_for_future
from bdai_ros2_wrappers.utilities import Tape

MessageT = TypeVar("MessageT")


class Subscription:
    """An ergonomic interface to for topic subscription in ROS 2.

    Subscription instances wrap `rclpy.Subscription` instances and allow
    synchronous and asynchronous iteration and fetching of published data.
    """

    def __init__(
        self,
        message_type: MessageT,
        topic_name: str,
        qos_profile: Optional[Union[QoSProfile, int]] = None,
        history_length: Optional[int] = None,
        node: Optional[Node] = None,
        **kwargs: Any,
    ) -> None:
        """Initializes the subscription.

        Args:
            message_type: Target message type class (as generated by ``rosidl``).
            topic_name: Name of the target topic in the ROS 2 graph.
            qos_profile: an optional quality-of-service profile or simply a history depth
            to use for the underlying native subscription, defaults to a history depth of 1.
            history_length: optional historic data size, defaults to 1
            node: optional node for the underlying native subscription, defaults to
            the current process node.
            kwargs: other keyword arguments are used to create the underlying native subscription.
            See `rclpy.node.Node.create_subscription` documentation for further reference.
        """
        node = node or scope.node()
        if node is None:
            raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
        self._node = node
        if history_length is None:
            history_length = 1
        if qos_profile is None:
            qos_profile = 1
        self._message_type = message_type
        self._topic_name = topic_name
        self._message_tape = Tape(history_length)
        self._topic_subscription = self._node.create_subscription(
            message_type,
            topic_name,
            self._message_tape.write,
            qos_profile,
            **kwargs,
        )
        self._node.context.on_shutdown(self._message_tape.close)

    @property
    def history(self) -> Sequence[Any]:
        """Gets the entire history of messages received so far."""
        return list(self._message_tape.content())

    @property
    def latest(self) -> Optional[Any]:
        """Gets the latest message received, if any."""
        return next(self._message_tape.content(), None)

    @property
    def update(self) -> Future:
        """Gets the a future to the next message yet to be received."""
        return self._message_tape.future_write

    def stream(
        self,
        *,
        forward_only: bool = False,
        buffer_size: Optional[int] = None,
        timeout_sec: Optional[float] = None,
    ) -> Iterator[Any]:
        """Iterates over messages as they come.

        Iteration stops when the given timeout expires or when the associated context
        is shutdown. Note that iterating over the message stream is a blocking operation.

        Args:
            forward_only: whether to ignore previosuly received messages.
            buffer_size: optional maximum size for the incoming messages buffer.
            If none is provided, the buffer will be grow unbounded.
            timeout_sec: optional timeout, in seconds, for a new message to be received.

        Returns:
            a lazy iterator over messages.
        """
        return self._message_tape.content(
            follow=True,
            forward_only=forward_only,
            buffer_size=buffer_size,
            timeout_sec=timeout_sec,
        )

    def cancel(self) -> None:
        """Cancels the message subscription if not cancelled already."""
        self._node.destroy_subscription(self._topic_subscription)
        self._message_tape.close()

    # Alias for improved readability
    unsubscribe = cancel


def wait_for_message_async(
    msg_type: MessageT,
    topic_name: str,
    *,
    qos_profile: Union[QoSProfile, int] = 1,
    node: Optional[Node] = None,
) -> Future:
    """Wait for message on a given topic asynchronously.

    Args:
        msg_type: type of message to wait for.
        topic_name: name of the topic to wait on.
        qos_profile: optional QoS profile for temporary topic subscription.
        node: optional node for temporary topic subscription, defaults to
        the current process-wide node (if any).

    Returns:
        A future for the incoming message.

    Raises:
        RuntimeError: if no node is available.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = Future()

    def callback(msg: MessageT) -> None:
        if not future.done():
            future.set_result(msg)

    sub = node.create_subscription(msg_type, topic_name, callback, qos_profile)
    future.add_done_callback(lambda future: node.destroy_subscription(sub))
    return future


def wait_for_message(
    msg_type: MessageT,
    topic_name: str,
    timeout_sec: Optional[float] = None,
    *,
    node: Optional[Node] = None,
    **kwargs: Any,
) -> Optional[MessageT]:
    """Wait for message on a given topic synchronously.

    Args:
        msg_type: type of message to wait for.
        topic_name: name of the topic to wait on.
        timeout_sec: optional timeout, in seconds, for the wait.
        node: An optional Node to provide. If none is provided, the one from the scope is used.
        kwargs: keyword argument to pass to `wait_for_message_async`

    See `wait_for_message_async` documentation for a reference on
    additional keyword arguments.

    Returns:
        The message received, or None on timeout.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = wait_for_message_async(msg_type, topic_name, node=node, **kwargs)
    if not wait_for_future(future, timeout_sec, context=node.context):
        future.cancel()
        return None
    return future.result()


def wait_for_messages(
    topics: typing.List,
    mtypes: typing.List,
    *,
    node: typing.Optional[rclpy.node.Node] = None,
    timeout_sec: typing.Optional[float] = None,
    **kwargs: typing.Any,
) -> typing.Union[None, typing.List[MessageT]]:
    """Waits for messages to arrive at multiple topics within a given time window.

    Uses message_filters.ApproximateTimeSynchronizer. This function blocks
    until receiving the messages or when a given timeout expires. Assumes the
    given node is spinning by some external executor.

    Requires the user to pass in a node, since
    message_filters.Subscriber requires a node upon construction.

    Args:
        topics: List of topics
        mtypes: List of message types, one for each topic.
        timeout_sec: Time in seconds to wait. None if forever.
            If exceeded timeout, self.messages will contain None for
            each topic.
        node: optional node for temporary topic subscription, defaults to
            queue_size
        kwargs: additional arguments passed into `wait_for_messages_async`.

    See `wait_for_messages_async` documentation for a reference on
    additional keyword arguments.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = wait_for_messages_async(topics, mtypes, node=node, **kwargs)
    if not wait_for_future(future, timeout_sec, context=node.context):
        future.cancel()
        return None
    return future.result()


def wait_for_messages_async(
    topics: typing.List,
    mtypes: typing.List,
    *,
    queue_size: int = 10,
    delay: float = 0.2,
    allow_headerless: bool = False,
    sleep: float = 0.5,
    qos_profiles: typing.Optional[typing.Dict[str, rclpy.qos.QoSProfile]] = None,
    node: typing.Optional[rclpy.node.Node] = None,
    callback_group: typing.Optional[rclpy.callback_groups.CallbackGroup] = None,
) -> rclpy.task.Future:
    """Asynchronous version of wait_for_messages

    Args:
        topics: List of topics
        mtypes: List of message types, one for each topic.
        queue_size: synchronizer message queue size
        delay: The delay in seconds for which the messages
            could be synchronized (i.e. the time window).
        allow_headerless: Whether it's ok for there to be
            no header in the messages.
        sleep: the amount of time to wait before checking
            whether messages are received
        qos_profiles: maps from topic name to QoSProfile
        node: optional node for temporary topic subscription, defaults to
            the current process-wide node (if any).
        callback_group: callback group for the message filter subscribers
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    if qos_profiles is None:
        qos_profiles = {}
    subs: typing.List[message_filters.Subscriber] = []
    for topic, mtype in zip(topics, mtypes):
        qos_profile = qos_profiles.get(topic, 10)
        subs.append(
            message_filters.Subscriber(node, mtype, topic, qos_profile=qos_profile, callback_group=callback_group),
        )
    future = rclpy.task.Future()

    def callback(*messages: typing.List[MessageT]) -> None:
        if not future.done():
            future.set_result(messages)

    ts = message_filters.ApproximateTimeSynchronizer(
        subs,
        queue_size,
        delay,
        allow_headerless=allow_headerless,
    )
    ts.registerCallback(callback)
    future.add_done_callback(lambda future: _destroy_subs(node, subs))
    return future


def _message_filters_subscriber(
    node: rclpy.node.Node,
    mtype: typing.Any,
    topic: str,
    qos_profile: typing.Union[rclpy.qos.QoSProfile, int] = 1,
    **kwargs: typing.Any,
) -> message_filters.Subscriber:
    return message_filters.Subscriber(node, mtype, topic, qos_profile=qos_profile, **kwargs)


def _destroy_subs(node: rclpy.node.Node, subs: typing.List[message_filters.Subscriber]) -> None:
    """destroy all message filter subscribers"""
    for mf_sub in subs:
        node.destroy_subscription(mf_sub.sub)
