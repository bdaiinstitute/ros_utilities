# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# See `conversions.py.jinja` template in the `proto2ros.output.templates` Python module.
import rclpy.serialization

{% for module_name in config.python_imports -%}
import {{ module_name }}
{% endfor %}
from proto2ros.conversions import convert
{% for module_name in config.inline_python_imports -%}
from {{ module_name }} import *
{% endfor -%}

{#
  Expands to code for ROS to Protobuf field conversion.

  Args:
    source: identifier of the ROS message field to convert from.
    destination: identifier of the Protobuf message field to convert to.
    spec: annotated ROS message field specification.
#}
{%- macro ros_to_proto_field_code(source, destination, spec) -%}
    {%- if not spec.type.is_primitive_type() -%}
        {%- set type_spec = known_message_specifications.get(to_ros_base_type(spec.type)) -%}
        {%- if type_spec and type_spec.annotations.get("proto-class") == "enum" -%}
            {#- Handle enum case i.e. extract integral values from ROS wrapper messages. -#}
            {%- if spec.type.is_array -%}
{{ destination }}.extend(item.value for item in {{ source }})
            {%- else -%}
{{ destination }} = {{ source }}.value
            {%- endif -%}
        {%- elif spec.type.is_array -%}
            {%- set input_item = itemize_python_identifier(source, "input_") -%}
            {%- set output_item = itemize_python_identifier(destination, "output_") -%}
            {%- if type_spec and type_spec.annotations.get("map-entry") -%}
                {#- Handle map case i.e. convert map entries, then update Protobuf messsage map. -#}
{{ output_item }} = {{ type_spec.annotations["proto-type"] | as_pb2_python_type }}()
for {{ input_item }} in {{ source }}:
    {{ ros_to_proto_composite_field_code_block(input_item, output_item, spec) | indent(4) }}
                {%- if type_spec.annotations.get("map-inplace") -%}
                {#- Then map value cannot be assigned, must be copied. #}
    {{ destination }}[{{ output_item }}.key].CopyFrom({{ output_item }}.value)
                {%- else %}
    {{ destination }}[{{ output_item }}.key] = {{ output_item }}.value
                {%- endif %}
            {%- else -%}{#- Handle sequence case i.e. just convert sequence items. #}
for {{ input_item }} in {{ source }}:
    {{ output_item }} = {{ destination }}.add()
    {{ ros_to_proto_composite_field_code_block(input_item, output_item, spec) | indent(4) }}
            {%- endif -%}
        {%- else -%}{#- Handle message case. -#}
{{ ros_to_proto_composite_field_code_block(source, destination, spec) }}
        {%- endif -%}
    {%- elif spec.annotations["proto-type"] == "bytes" -%}
        {#- Handle bytes case. -#}
        {%- if to_ros_base_type(spec.type) == "proto2ros/Bytes" -%}
{{ destination }}.extend(blob.data.tobytes() for blob in {{ source }})
        {%- else -%}
{{ destination }} = {{ source }}.tobytes()
        {%- endif -%}
    {%- else -%}{#- Handle primitive types case. -#}
        {%- if spec.type.is_array -%}
{{ destination }}.extend({{ source }})
        {%- else -%}
{{ destination }} = {{ source }}
        {%- endif -%}
    {%- endif -%}
{%- endmacro -%}

{#
  Expands to a code block for ROS to Protobuf composite field conversion.

  Args:
    source: identifier for the ROS message field to convert from.
    destination: identifier for the Protobuf message field to convert to.
    spec: annotated ROS message field specification.

  Note: code block may expand within a for-loop, during a repeated field expansion.
#}
{%- macro ros_to_proto_composite_field_code_block(source, destination, spec) -%}
    {%- set type_spec = known_message_specifications.get(to_ros_base_type(spec.type)) -%}
    {%- if spec.annotations.get("type-erased") -%}
        {#- ROS message must be deserialized for conversion. -#}
if {{ source }}.type_name != "{{ spec.type | as_ros_base_type }}":
    raise ValueError("expected {{ spec.type | as_ros_base_type }} message for {{ spec.name }} member, got %s" % {{ source }}.type)
typed_{{ source | python_identifier_name }}_message = rclpy.serialization.deserialize_message({{ source }}.value.tobytes(), {{ spec.type | as_ros_base_type | as_ros_python_type }})
convert_{{ spec.type | as_ros_base_type | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto(typed_{{ source | python_identifier_name }}_message, {{ destination }})
    {%- elif spec.annotations.get("type-casted") -%}
        {#- ROS message must be converted and packed for assignment. -#}
typed_{{ source | python_identifier_name }}_message = {{ spec.annotations["proto-type"] | as_pb2_python_type }}()
convert_{{ spec.type | as_ros_base_type | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto({{ source }}, typed_{{ source | python_identifier_name }}_message)
{{ destination }}.Pack(typed_{{ source | python_identifier_name }}_message)
    {%- elif spec.annotations.get("type-casts") -%}
        {#- ROS message must be deserialized according to type, then converted, then packed for assignment. -#}
        {% for proto_type_name, ros_type_name in spec.annotations["type-casts"] -%}
            {%- if loop.first -%}
if {{ source }}.type_name == "{{ ros_type_name }}":
            {%- else %}
elif {{ source }}.type_name == "{{ ros_type_name }}":
            {%- endif %}
    typed_{{ ros_type_name | as_python_identifier | python_identifier_name }}_message = rclpy.serialization.deserialize_message({{ source }}.value.tobytes(), {{ ros_type_name | as_ros_python_type }})
    typed_{{ proto_type_name | as_python_identifier | python_identifier_name }}_message = {{ proto_type_name | as_pb2_python_type }}()
    convert_{{ ros_type_name | as_python_identifier }}_message_to_{{ proto_type_name | as_python_identifier }}_proto(typed_{{ ros_type_name | as_python_identifier | python_identifier_name }}_message, typed_{{ proto_type_name | as_python_identifier | python_identifier_name }}_message)
    {{ destination }}.Pack(typed_{{ proto_type_name | as_python_identifier | python_identifier_name }}_message)
       {%- endfor %}
else:
    raise ValueError("unexpected %s in {{ spec.name }} member:" % ros_msg.{{ spec.name }}.type)
    {%- elif type_spec and type_spec.annotations.get("tagged") -%}
        {#- Handle one-of field case i.e. determine and convert the ROS message member that is set. -#}
        {%- set tag_field_spec = type_spec.annotations["tag"] -%}
which = {{ source }}.{{ tag_field_spec.name }} or {{ source }}.{{ tag_field_spec.annotations["alias"] }}
        {%- for tag_spec, member_spec in type_spec.annotations["tagged"] %}
            {%- if loop.first %}
if which == {{ type_spec.base_type | string | as_ros_python_type }}.{{ tag_spec.name }}:
            {%- else %}
elif which == {{ type_spec.base_type | string | as_ros_python_type }}.{{ tag_spec.name }}:
            {%- endif %}
            {%- set source_member = source + "." + member_spec.name -%}
            {%- set destination_member = destination.rpartition(".")[0] + "." + member_spec.annotations.get("proto-name", member_spec.name) %}
    {{ ros_to_proto_field_code(source_member, destination_member, member_spec) | indent(4) }}
        {%- endfor %}
else:
    pass
    {%- else -%}
        {#- Handle the generic ROS message case (because it is appropriate or because we do not know any better). -#}
convert_{{ spec.type | as_ros_base_type | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto({{ source }}, {{ destination }})
    {%- endif -%}
{%- endmacro -%}

{#
  Expands to code for Protobuf to ROS field conversion.

  Args:
    source: identifier of the Protobuf message field to convert from.
    destination: identifier of the ROS message field to convert to.
    spec: annotated ROS message field specification.
#}
{%- macro proto_to_ros_field_code(source, destination, spec) -%}
    {%- if not spec.type.is_primitive_type() -%}
        {%- set type_spec = known_message_specifications.get(to_ros_base_type(spec.type)) -%}
        {%- if type_spec and type_spec.annotations.get("proto-class") == "enum" -%}
            {#- Handle enum case i.e. wrap integral values in ROS messages. -#}
            {%- if spec.type.is_array -%}
{{ destination }} = [{{ spec.type | as_ros_base_type | as_ros_python_type }}(value=value) for value in {{ source }}]
            {%- else -%}
{{ destination }}.value = {{ source }}
            {%- endif -%}
        {%- elif spec.type.is_array -%}
            {%- set input_item = itemize_python_identifier(source, "input_") -%}
            {%- set output_item = itemize_python_identifier(destination, "output_") -%}
            {%- if type_spec and type_spec.annotations.get("map-entry") %}
                {#- Handle map case i.e. reconstruct map entries, the convert, then assign. -#}
                {%- set input_iterable = input_item + "_entries" -%}
{{ input_iterable }} = [{{ type_spec.annotations["proto-type"] | as_pb2_python_type }}(key=key, value=value) for key, value in {{ source }}.items()]
            {%- else -%}
                {#- Handle sequence case. -#}
                {%- set input_iterable = source -%}
            {%- endif %}
for {{ input_item }} in {{ input_iterable }}:
            {%- if not spec.annotations.get("type-erased") %}
    {{ output_item }} = {{ spec.type | as_ros_base_type | as_ros_python_type }}()
            {%- else %}{#- It must convert to a type erased ROS message. #}
    {{ output_item }} = proto2ros.msg.Any()
            {%- endif %}
    {{ proto_to_ros_composite_field_code_block(input_item, output_item, spec) | indent(4) }}
    {{ destination }}.append({{ output_item }})
        {%- else -%}{#- Handle message case. -#}
{{ proto_to_ros_composite_field_code_block(source, destination, spec) }}
        {%- endif -%}
    {%- elif spec.annotations["proto-type"] == "bytes" -%}
        {#- Handle bytes case. -#}
        {%- if to_ros_base_type(spec.type) == "proto2ros/Bytes" -%}
{{ destination }} = [proto2ros.msg.Bytes(data=blob) for blob in {{ source }}]
        {%- else -%}
{{ destination }} = {{ source }}
        {%- endif -%}
    {%- else -%}{#- Handle primitive types case. -#}
{{ destination }} = {{ source }}
    {%- endif -%}
{%- endmacro -%}

{#
  Expands to a code block for Protobuf to ROS composite field conversion.

  Args:
    source: identifier of the Protobuf message field to convert from.
    destination: identifier of the ROS message field to convert to.
    spec: annotated ROS message field specification.

  Note: code block may expand within a for-loop, during a repeated field expansion.
#}
{%- macro proto_to_ros_composite_field_code_block(source, destination, spec) -%}
    {%- set type_spec = known_message_specifications.get(to_ros_base_type(spec.type)) -%}
    {%- if spec.annotations.get("type-erased") -%}
        {#- ROS message must be serialized for assignment. -#}
typed_{{ source | python_identifier_name }}_message = {{ spec.type | as_ros_base_type | as_ros_python_type }}()
convert_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto_to_{{ spec.type | as_ros_base_type | as_python_identifier }}_message({{ source }}, typed_{{ source | python_identifier_name }}_message)
{{ destination }}.value = rclpy.serialization.serialize_message(typed_{{ source | python_identifier_name }}_message)
{{ destination }}.type_name = "{{ spec.type | as_ros_base_type }}"
    {%- elif spec.annotations.get("type-casted") -%}
        {#- Protobuf message must be unpacked for conversion. -#}
typed_{{ source | python_identifier_name }}_message = {{ spec.annotations["proto-type"] | as_pb2_python_type }}()
{{ source }}.Unpack(typed_{{ source | python_identifier_name }}_message)
convert_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto_to_{{ spec.type | as_ros_base_type | as_python_identifier }}_message(typed_{{ source | python_identifier_name }}_message, {{ destination }})
    {%- elif spec.annotations.get("type-casts") -%}
        {#- Protobuf message must be unpacked according to type, then converted, then serialized for assignment. -#}
        {%- for proto_type_name, ros_type_name in spec.annotations["type-casts"] -%}
            {%- if loop.first -%}
if {{ source }}.Is({{ proto_type_name | as_pb2_python_type }}.DESCRIPTOR):
            {%- else %}
elif {{ source }}.Is({{ proto_type_name | as_pb2_python_type }}.DESCRIPTOR):
            {%- endif %}
    typed_{{ proto_type_name | as_python_identifier | python_identifier_name }}_message = {{ proto_type_name | as_pb2_python_type }}()
    ok = {{ source }}.Unpack(typed_{{ proto_type_name | as_python_identifier | python_identifier_name }}_message)
    assert ok, "Failed to unpack any protobuf, internal error"
    typed_{{ ros_type_name | as_python_identifier | python_identifier_name }}_message = {{ ros_type_name | as_ros_python_type }}()
    convert_{{ proto_type_name | as_python_identifier }}_proto_to_{{ ros_type_name | as_python_identifier }}_message(typed_{{ proto_type_name | as_python_identifier | python_identifier_name }}_message, typed_{{ ros_type_name | as_python_identifier | python_identifier_name }}_message)
    {{ destination }}.value = rclpy.serialization.serialize_message(typed_{{ ros_type_name | as_python_identifier | python_identifier_name }}_message)
    {{ destination }}.type_name = "{{ ros_type_name }}"
        {%- endfor %}
else:
    raise ValueError("unknown protobuf message type in {{ spec.name }} member: %s" % {{ source }}.type_url)
    {%- elif type_spec and type_spec.annotations.get("tagged") -%}
        {#- Handle one-of field case i.e. determine and convert the Protobuf message member that is set. -#}
which = {{ source.rpartition(".")[0] }}.WhichOneof("{{ spec.name }}")
        {%- set tag_field_spec = type_spec.annotations["tag"] %}
        {%- for tag_spec, member_spec in type_spec.annotations["tagged"] %}
            {%- if loop.first %}
if which == "{{ member_spec.name }}":
            {%- else %}
elif which == "{{ member_spec.name }}":
            {%- endif %}
            {%- set source_member = source.rpartition(".")[0] + "." + member_spec.annotations.get("proto-name", member_spec.name) -%}
            {%- set destination_member = destination + "." + member_spec.name %}
    {{ proto_to_ros_field_code(source_member, destination_member, member_spec) | indent(4) }}
    {{ destination }}.{{ tag_field_spec.name }} = {{ type_spec.base_type | string | as_ros_python_type }}.{{ tag_spec.name }}
    {{ destination }}.{{ tag_field_spec.annotations["alias"] }} = {{ destination }}.{{ tag_field_spec.name }}
        {%- endfor %}
else:
    {{ destination }}.{{ tag_field_spec.name }} = 0
    {{ destination }}.{{ tag_field_spec.annotations["alias"] }} = 0
    {%- else -%}
        {#- Handle the generic Protobuf message case (because it is appropriate or because we do not know any better). -#}
convert_{{ spec.annotations["proto-type"] | as_python_identifier }}_proto_to_{{ spec.type | as_ros_base_type | as_python_identifier }}_message({{ source }}, {{ destination }})
    {%- endif -%}
{%- endmacro %}
{% for spec in message_specifications if spec.annotations.get("proto-class") == "message" %}
@convert.register({{ spec.base_type | string | as_ros_python_type }}, {{ spec.annotations["proto-type"] | as_pb2_python_type }})
def convert_{{ spec.base_type | string | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto(
    ros_msg: {{ spec.base_type | string | as_ros_python_type }}, proto_msg: {{ spec.annotations["proto-type"] | as_pb2_python_type }}
) -> None:
    """Convert from {{ spec.base_type }} ROS messages to {{ spec.annotations["proto-type"] }} Protobuf messages."""
    {%- if spec.fields %}
    proto_msg.Clear()
        {%- for field_spec in spec.fields if field_spec.name != "has_field" %}
            {%- set source = "ros_msg." + field_spec.name -%}
            {%- set destination = "proto_msg." + field_spec.annotations.get("proto-name", field_spec.name) -%}
            {%- if field_spec.annotations["optional"] %}{#- Check for field presence before use. #}
    if ros_msg.has_field & {{ spec.base_type | string | as_ros_python_type }}.{{ field_spec.name | upper }}_FIELD_SET:
        {{ ros_to_proto_field_code(source, destination, field_spec) | indent(8) }}
            {%- else %}
    {{ ros_to_proto_field_code(source, destination, field_spec) | indent(4) }}
            {%- endif -%}
        {%- endfor -%}
    {% else -%}{#- Handle empty message. #}
    proto_msg.SetInParent()
    {%- endif %}


convert_{{ spec.base_type | string | as_python_identifier }}_to_proto = \
    convert_{{ spec.base_type | string | as_python_identifier }}_message_to_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto


@convert.register({{ spec.annotations["proto-type"] | as_pb2_python_type }}, {{ spec.base_type | string | as_ros_python_type }})
def convert_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto_to_{{ spec.base_type | string | as_python_identifier }}_message(
    proto_msg: {{ spec.annotations["proto-type"] | as_pb2_python_type }}, ros_msg: {{ spec.base_type | string | as_ros_python_type }}
) -> None:
    """Convert from {{ spec.annotations["proto-type"] }} Protobuf messages to {{ spec.base_type }} ROS messages."""
    {%- if spec.fields %}
        {%- if spec.annotations["has-optionals"] %}
    ros_msg.has_field = 0
        {%- endif -%}
        {%- for field_spec in spec.fields if field_spec.name != "has_field" -%}
           {%- set source = "proto_msg." + field_spec.annotations.get("proto-name", field_spec.name) -%}
           {%- set destination = "ros_msg." + field_spec.name -%}
           {%- if field_spec.annotations["optional"] -%}{#- Check for field presence before use. #}
    if proto_msg.HasField("{{ field_spec.annotations.get("proto-name", field_spec.name) }}"):
        {{ proto_to_ros_field_code(source, destination, field_spec) | indent(8) }}
        ros_msg.has_field |= {{ spec.base_type | string | as_ros_python_type }}.{{ field_spec.name | upper }}_FIELD_SET
            {%- else %}
    {{ proto_to_ros_field_code(source, destination, field_spec) | indent(4) }}
            {%- endif -%}
        {%- endfor -%}
    {% else -%}{#- Handle empty message. #}
    pass
    {%- endif %}


convert_proto_to_{{ spec.base_type | string | as_python_identifier }} = \
    convert_{{ spec.annotations["proto-type"] | as_python_identifier  }}_proto_to_{{ spec.base_type | string | as_python_identifier }}_message

{% endfor -%}
