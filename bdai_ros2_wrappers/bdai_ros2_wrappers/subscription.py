# Copyright (c) 2023 Boston Dynamics AI Institute Inc.  All rights reserved.

from collections.abc import Sequence
from typing import Any, Iterator, Optional, TypeVar, Union

import message_filters
from rclpy.callback_groups import CallbackGroup
from rclpy.node import Node
from rclpy.qos import QoSProfile
from rclpy.task import Future

import bdai_ros2_wrappers.scope as scope
from bdai_ros2_wrappers.futures import wait_for_future
from bdai_ros2_wrappers.utilities import Tape

MessageT = TypeVar("MessageT")


class Subscription:
    """An ergonomic interface to for topic subscription in ROS 2.

    Subscription instances wrap `rclpy.Subscription` instances and allow
    synchronous and asynchronous iteration and fetching of published data.
    """

    def __init__(
        self,
        message_type: MessageT,
        topic_name: str,
        qos_profile: Optional[Union[QoSProfile, int]] = None,
        history_length: Optional[int] = None,
        node: Optional[Node] = None,
        **kwargs: Any,
    ) -> None:
        """Initializes the subscription.

        Args:
            message_type: Target message type class (as generated by ``rosidl``).
            topic_name: Name of the target topic in the ROS 2 graph.
            qos_profile: an optional quality-of-service profile or simply a history depth
            to use for the underlying native subscription, defaults to a history depth of 1.
            history_length: optional historic data size, defaults to 1
            node: optional node for the underlying native subscription, defaults to
            the current process node.
            kwargs: other keyword arguments are used to create the underlying native subscription.
            See `rclpy.node.Node.create_subscription` documentation for further reference.
        """
        node = node or scope.node()
        if node is None:
            raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
        self._node = node
        if history_length is None:
            history_length = 1
        if qos_profile is None:
            qos_profile = 1
        self._message_type = message_type
        self._topic_name = topic_name
        self._message_tape = Tape(history_length)
        self._topic_subscription = self._node.create_subscription(
            message_type,
            topic_name,
            self._message_tape.write,
            qos_profile,
            **kwargs,
        )
        self._node.context.on_shutdown(self._message_tape.close)

    @property
    def history(self) -> Sequence[Any]:
        """Gets the entire history of messages received so far."""
        return list(self._message_tape.content())

    @property
    def latest(self) -> Optional[Any]:
        """Gets the latest message received, if any."""
        return next(self._message_tape.content(), None)

    @property
    def update(self) -> Future:
        """Gets the a future to the next message yet to be received."""
        return self._message_tape.future_write

    def stream(
        self,
        *,
        forward_only: bool = False,
        buffer_size: Optional[int] = None,
        timeout_sec: Optional[float] = None,
    ) -> Iterator[Any]:
        """Iterates over messages as they come.

        Iteration stops when the given timeout expires or when the associated context
        is shutdown. Note that iterating over the message stream is a blocking operation.

        Args:
            forward_only: whether to ignore previosuly received messages.
            buffer_size: optional maximum size for the incoming messages buffer.
            If none is provided, the buffer will be grow unbounded.
            timeout_sec: optional timeout, in seconds, for a new message to be received.

        Returns:
            a lazy iterator over messages.
        """
        return self._message_tape.content(
            follow=True,
            forward_only=forward_only,
            buffer_size=buffer_size,
            timeout_sec=timeout_sec,
        )

    def cancel(self) -> None:
        """Cancels the message subscription if not cancelled already."""
        self._node.destroy_subscription(self._topic_subscription)
        self._message_tape.close()

    # Alias for improved readability
    unsubscribe = cancel


def wait_for_message_async(
    msg_type: MessageT,
    topic_name: str,
    *,
    qos_profile: Union[QoSProfile, int] = 1,
    node: Optional[Node] = None,
) -> Future:
    """Wait for message on a given topic asynchronously.

    Args:
        msg_type: type of message to wait for.
        topic_name: name of the topic to wait on.
        qos_profile: optional QoS profile for temporary topic subscription.
        node: optional node for temporary topic subscription, defaults to
        the current process-wide node (if any).

    Returns:
        A future for the incoming message.

    Raises:
        RuntimeError: if no node is available.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = Future()

    def callback(msg: MessageT) -> None:
        if not future.done():
            future.set_result(msg)

    sub = node.create_subscription(msg_type, topic_name, callback, qos_profile)
    future.add_done_callback(lambda future: node.destroy_subscription(sub))
    return future


def wait_for_message(
    msg_type: MessageT,
    topic_name: str,
    timeout_sec: Optional[float] = None,
    *,
    node: Optional[Node] = None,
    **kwargs: Any,
) -> Optional[MessageT]:
    """Wait for message on a given topic synchronously.

    Args:
        msg_type: type of message to wait for.
        topic_name: name of the topic to wait on.
        timeout_sec: optional timeout, in seconds, for the wait.
        node: An optional Node to provide. If none is provided, the one from the scope is used.
        kwargs: keyword argument to pass to `wait_for_message_async`

    See `wait_for_message_async` documentation for a reference on
    additional keyword arguments.

    Returns:
        The message received, or None on timeout.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = wait_for_message_async(msg_type, topic_name, node=node, **kwargs)
    if not wait_for_future(future, timeout_sec, context=node.context):
        future.cancel()
        return None
    return future.result()


def wait_for_messages(
    topic_names: Sequence[str],
    message_types: Sequence[MessageT],
    *,
    timeout_sec: Optional[float] = None,
    node: Optional[Node] = None,
    **kwargs: Any,
) -> Optional[Sequence[Any]]:
    """Waits for messages to arrive at multiple topics within a given time window.

    Uses message_filters.ApproximateTimeSynchronizer. This function blocks
    until receiving the messages or when a given timeout expires. Assumes the
    given node is spinning by some external executor.

    Requires the user to pass in a node, since
    message_filters.Subscriber requires a node upon construction.

    Args:
        topic_names: list of topic names
        message_types: list of message types, one for each topic.
        timeout_sec: optional time in seconds to wait. None if forever.
        node: optional node for temporary topic subscription
        kwargs: additional arguments passed into `wait_for_messages_async`.

    See `wait_for_messages_async` documentation for a reference on
    additional keyword arguments.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = wait_for_messages_async(topic_names, message_types, node=node, **kwargs)
    if not wait_for_future(future, timeout_sec, context=node.context):
        future.cancel()
        return None
    return future.result()


def wait_for_messages_async(
    topic_names: Sequence[str],
    message_types: Sequence[MessageT],
    *,
    queue_size: int = 10,
    delay: float = 0.2,
    allow_headerless: bool = False,
    node: Optional[Node] = None,
    qos_profiles: Optional[Sequence[Optional[QoSProfile]]] = None,
    callback_group: Optional[CallbackGroup] = None,
) -> Future:
    """Asynchronous version of wait_for_messages

    Args:
        topic_names: list of topic names
        message_types: List of message types, one for each topic.
        queue_size: synchronizer message queue size
        delay: the delay in seconds for which the messages could be
        synchronized (i.e. the time window).
        allow_headerless: whether it's ok for there to be no header in the messages.
        qos_profiles: optional list of QoS profiles, one for each topic.
        If no QoS profile is specified for a given topic, the default profile with
        a history depth of 10 will be used.
        node: optional node for temporary topic subscription, defaults to the current
        process-wide node (if any).
        callback_group: optional callback group for the message filter subscribers.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")

    if qos_profiles is None:
        qos_profiles = [None] * len(topic_names)

    subscribers = [
        message_filters.Subscriber(
            node,
            message_type,
            topic_name,
            qos_profile=qos_profile or 10,
            callback_group=callback_group,
        )
        for topic_name, message_type, qos_profile in zip(topic_names, message_types, qos_profiles)
    ]

    future = Future()

    def callback(*messages: Sequence[Any]) -> None:
        nonlocal future
        if not future.done():
            future.set_result(messages)

    sync = message_filters.ApproximateTimeSynchronizer(
        subscribers,
        queue_size,
        delay,
        allow_headerless,
    )
    sync.registerCallback(callback)

    def cleanup_subscribers(_: Future) -> None:
        nonlocal node, subscribers
        assert node is not None
        for sub in subscribers:
            node.destroy_subscription(sub.sub)

    future.add_done_callback(cleanup_subscribers)
    return future
