# Copyright (c) 2023 Boston Dynamics AI Institute Inc.  All rights reserved.

from collections.abc import Sequence
from typing import Any, Iterator, Optional, TypeVar, Union

from rclpy.node import Node
from rclpy.qos import QoSProfile
from rclpy.task import Future

import bdai_ros2_wrappers.scope as scope
from bdai_ros2_wrappers.futures import wait_for_future
from bdai_ros2_wrappers.utilities import Tape

MessageT = TypeVar("MessageT")


class Subscription:
    """An ergonomic interface to for topic subscription in ROS 2.

    Subscription instances wrap `rclpy.Subscription` instances and allow
    synchronous and asynchronous iteration and fetching of published data.
    """

    def __init__(
        self,
        message_type: MessageT,
        topic_name: str,
        qos_profile: Optional[Union[QoSProfile, int]] = None,
        history_length: Optional[int] = None,
        node: Optional[Node] = None,
        **kwargs: Any,
    ) -> None:
        """Initializes the subscription.

        Args:
            message_type: Target message type class (as generated by ``rosidl``).
            topic_name: Name of the target topic in the ROS 2 graph.
            qos_profile: an optional quality-of-service profile or simply a history depth
            to use for the underlying native subscription, defaults to a history depth of 1.
            history_length: optional historic data size, defaults to 1
            node: optional node for the underlying native subscription, defaults to
            the current process node.
            kwargs: other keyword arguments are used to create the underlying native subscription.
            See `rclpy.node.Node.create_subscription` documentation for further reference.
        """
        node = node or scope.node()
        if node is None:
            raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
        self._node = node
        if history_length is None:
            history_length = 1
        if qos_profile is None:
            qos_profile = 1
        self._message_type = message_type
        self._topic_name = topic_name
        self._message_tape = Tape(history_length)
        self._topic_subscription = self._node.create_subscription(
            message_type,
            topic_name,
            self._message_tape.write,
            qos_profile,
            **kwargs,
        )
        self._node.context.on_shutdown(self._message_tape.close)

    @property
    def history(self) -> Sequence[Any]:
        """Gets the entire history of messages received so far."""
        return list(self._message_tape.content())

    @property
    def latest(self) -> Optional[Any]:
        """Gets the latest message received, if any."""
        return next(self._message_tape.content(), None)

    @property
    def update(self) -> Future:
        """Gets the a future to the next message yet to be received."""
        return self._message_tape.future_write

    def stream(
        self,
        *,
        forward_only: bool = False,
        buffer_size: Optional[int] = None,
        timeout_sec: Optional[float] = None,
    ) -> Iterator[Any]:
        """Iterates over messages as they come.

        Iteration stops when the given timeout expires or when the associated context
        is shutdown. Note that iterating over the message stream is a blocking operation.

        Args:
            forward_only: whether to ignore previosuly received messages.
            buffer_size: optional maximum size for the incoming messages buffer.
            If none is provided, the buffer will be grow unbounded.
            timeout_sec: optional timeout, in seconds, for a new message to be received.

        Returns:
            a lazy iterator over messages.
        """
        return self._message_tape.content(
            follow=True,
            forward_only=forward_only,
            buffer_size=buffer_size,
            timeout_sec=timeout_sec,
        )

    def cancel(self) -> None:
        """Cancels the message subscription if not cancelled already."""
        self._node.destroy_subscription(self._topic_subscription)
        self._message_tape.close()

    # Alias for improved readability
    unsubscribe = cancel


def wait_for_message_async(
    msg_type: MessageT,
    topic_name: str,
    *,
    qos_profile: Union[QoSProfile, int] = 1,
    node: Optional[Node] = None,
) -> Future:
    """Wait for message on a given topic asynchronously.

    Args:
        msg_type: type of message to wait for.
        topic_name: name of the topic to wait on.
        qos_profile: optional QoS profile for temporary topic subscription.
        node: optional node for temporary topic subscription, defaults to
        the current process-wide node (if any).

    Returns:
        A future for the incoming message.

    Raises:
        RuntimeError: if no node is available.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = Future()

    def callback(msg: MessageT) -> None:
        if not future.done():
            future.set_result(msg)

    sub = node.create_subscription(msg_type, topic_name, callback, qos_profile)
    future.add_done_callback(lambda future: node.destroy_subscription(sub))
    return future


def wait_for_message(
    msg_type: MessageT,
    topic_name: str,
    timeout_sec: Optional[float] = None,
    *,
    node: Optional[Node] = None,
    **kwargs: Any,
) -> Optional[MessageT]:
    """Wait for message on a given topic synchronously.

    Args:
        msg_type: type of message to wait for.
        topic_name: name of the topic to wait on.
        timeout_sec: optional timeout, in seconds, for the wait.
        node: An optional Node to provide. If none is provided, the one from the scope is used.
        kwargs: keyword argument to pass to `wait_for_message_async`

    See `wait_for_message_async` documentation for a reference on
    additional keyword arguments.

    Returns:
        The message received, or None on timeout.
    """
    node = node or scope.node()
    if node is None:
        raise ValueError("no ROS 2 node available (did you use bdai_ros2_wrapper.process.main?)")
    future = wait_for_message_async(msg_type, topic_name, node=node, **kwargs)
    if not wait_for_future(future, timeout_sec, context=node.context):
        future.cancel()
        return None
    return future.result()
